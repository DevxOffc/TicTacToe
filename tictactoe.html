<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play a cosmic-themed Tic Tac Toe game online. Challenge the AI in various modes from 3x3 to 10x10 grids.">
    <meta name="keywords" content="tic tac toe, online game, browser game, html, css, javascript, cosmic, strategy game">
    <meta name="author" content="Shivam Kumar">
    <link rel="icon" href="assetbg/f.jpg" type="image/png">
    <title>Tic Tac Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        #video-background {
            position: fixed;
            top: 0;
            left: 0;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            z-index: -1;
            object-fit: cover;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 0;
        }
        
        .container {
            position: relative;
            /* background-color: rgba(4, 21, 147, 0.3); */
            border-radius: 15px;
            padding: 25px;
            max-width: 95%;
            width: 900px;
            text-align: center;
            margin: 40px auto;
            z-index: 1;
        }
        
        h1 {
            color: #00ddff;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 128, 255, 0.1);
        }
        
        .mode-selection {
            margin-bottom: 25px;
        }
        
        .mode-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .mode-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 50px;
            background-color: #0000ff;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .mode-btn.easy { background-color: #00ffa6; color: black; }
        .mode-btn.medium { background-color: #009dff;color: black; }
        .mode-btn.hard { background-color: #1b2aff; color: black; }
        .mode-btn.pro { background-color: #7a1bff;color: black; }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: #000000;
            border-radius: 50px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .status {
            font-size: 1.2rem;
            font-weight: bold;
            color: #0075ea;
        }
        
        .restart-btn {
            padding: 8px 16px;
            background-color: #3a007c;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .restart-btn:hover {
            background-color: #0084b0;
        }
        
        .game-board {
            display: inline-block;
            margin: 0 auto;
            border: 3px solid #9900ff;
            border-radius: 10px;
            overflow: hidden;
            background-color: #ecf0f1;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            max-width: 100%;
            overflow-x: auto;
        }
        
        .board-container {
            display: grid;
            gap: 2px;
            padding: 5px;
            background-color: #000000;
        }
        
        .cell {
            width: 45px;
            height: 45px;
            background-color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cell:hover {
            border: 2px solid black;
            background-color: #d6dbdf;
            transform: scale(1.05);
        }
        
        .cell.x {
            color: #ff1900;
        }
        
        .cell.o {
            color: #0099ff;
        }
        
        .cell.used-in-win {
            background-color: #f8f9fa;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .winning-cell {
            animation: pulse 1.5s infinite;
            background-color: #6c4fff;
            color: white;
        }
        
        @keyframes pulse {
            0% { background-color: #2e53cc; }
            50% { background-color: #2734ae; }
            100% { background-color: #2e38cc; }
        }
        
        .instructions {
            margin-top: 25px;
            padding: 15px;
            background-color: #8606ff;
            border-radius: 8px;
            text-align: left;
        }
        
        .instructions h3 {
            color: #00fffb;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            list-style-type: none;
            padding-left: 20px;
            margin-bottom: 15px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            color: #000000;
        }
        
        .instructions li::before {
            content: "‚Ä¢";
            color: #3498db;
            font-weight: bold;
            display: inline-block;
            width: 1em;
            margin-left: -1em;
        }
        
        .win-counter {
            margin-top: 15px;
            padding: 10px;
            background-color: #28005a;
            color: #00fffb;
            border-radius: 8px;
            border-left: 10px solid #00fbff;
            text-align: center;
            font-weight: bold;
        }
        
        .win-progress {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 5px;
        }
        
        .win-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #000000;
            border: 2px solid #0004ff;
        }
        
        .win-dot.achieved {
            background-color: #1eff00;
            border-color: #000000;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                margin: 20px auto;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .cell {
                width: 30px;
                height: 30px;
                font-size: 1rem;
            }
            
            .mode-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .win-dot {
                width: 15px;
                height: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .cell {
                width: 25px;
                height: 25px;
                font-size: 0.9rem;
            }
            
            .mode-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            .status {
                font-size: 1rem;
            }
            
            .game-info {
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
        }
        
        /* Fallback for browsers that don't support video backgrounds */
        @supports not (object-fit: cover) {
            #video-background {
                display: none;
            }
            
            body {
                background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
                min-height: 100vh;
            }
        }
    </style>
</head>
<body>
    <!-- Video background -->
    <video id="video-background" autoplay muted loop playsinline>
        <source src="assetbg/bg2.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    <div class="overlay"></div>
    
    <div class="container">
        <h1>Tic Tac Toe</h1>
        
        <div class="mode-selection">
            <div class="mode-buttons">
                <button class="mode-btn easy" data-mode="easy">Easy (3√ó3)</button>
                <button class="mode-btn medium" data-mode="medium">Medium (5√ó5)</button>
                <button class="mode-btn hard" data-mode="hard">Hard (7√ó7)</button>
                <button class="mode-btn pro" data-mode="pro">Pro (10√ó10)</button>
            </div>
        </div>
        
        <div class="game-info">
            <div class="status">Select a mode to start playing</div>
            <button class="restart-btn">Restart Game</button>
        </div>
        
        <div class="win-counter" id="win-counter" style="display: none;">
            Wins: <span id="player-wins">0</span> (You) - <span id="computer-wins">0</span> (Computer)
            <div class="win-progress" id="win-progress">
                <!-- Win progress dots will be generated here -->
            </div>
        </div>
        
        <div class="game-board">
            <div class="board-container" id="board-container">
                <!-- Board will be generated here -->
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Play:</h3>
            <ul>
                <li><strong>üòèEasy Mode:</strong> 3√ó3 grid, align 3 boxes to win</li>
                <li><strong>üôÇMedium Mode:</strong> 5√ó5 grid, align 4 boxes to win</li>
                <li><strong>üòìHard Mode:</strong> 7√ó7 grid, align 5 boxes to win</li>
                <li><strong>üôÉPro Mode:</strong> 10√ó10 grid, align 4 boxes. Need 4 wins to complete the game</li>
                <li>You play as X, computer plays as O</li>
            </ul>
            <p><strong>ü§îStrategy Tip:</strong> In Pro mode, plan your moves carefully as boxes used in wins become unavailable for future wins!</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardContainer = document.getElementById('board-container');
            const statusDisplay = document.querySelector('.status');
            const restartBtn = document.querySelector('.restart-btn');
            const modeButtons = document.querySelectorAll('.mode-btn');
            const winCounter = document.getElementById('win-counter');
            const playerWinsSpan = document.getElementById('player-wins');
            const computerWinsSpan = document.getElementById('computer-wins');
            const winProgress = document.getElementById('win-progress');
            const videoBackground = document.getElementById('video-background');
            
            let currentMode = '';
            let board = [];
            let gameActive = false;
            let currentPlayer = 'X';
            let gameState = {};
            let boardSize = 0;
            let requiredLength = 0;
            let winningIndices = [];
            let usedInWinIndices = new Set(); // Track boxes used in wins for Pro mode
            
            // Ensure video plays correctly
            videoBackground.play().catch(error => {
                console.log("Video autoplay prevented: ", error);
                // Fallback to showing play button or just continue without video
            });
            
            // Winning messages
            const winningMessage = () => `Player ${currentPlayer} has won this round!`;
            const drawMessage = () => `Game ended in a draw!`;
            const currentPlayerTurn = () => `It's ${currentPlayer}'s turn`;
            const gameWonMessage = () => `Player ${currentPlayer} has won the game with 4 wins!`;
            
            // Mode configurations
            const modes = {
                easy: { size: 3, required: 3 },
                medium: { size: 5, required: 4 },
                hard: { size: 7, required: 5 },
                pro: { size: 10, required: 4, winsRequired: 4 } // 4 aligned boxes, 4 wins needed
            };
            
            // Initialize game with selected mode
            function initGame(mode) {
                currentMode = mode;
                boardSize = modes[mode].size;
                requiredLength = modes[mode].required;
                winningIndices = [];
                usedInWinIndices.clear();
                
                // Reset game state
                gameState = {
                    X: { wins: 0, positions: [] },
                    O: { wins: 0, positions: [] }
                };
                
                // Create empty board
                board = Array(boardSize * boardSize).fill(null);
                
                // Generate game board UI
                boardContainer.innerHTML = '';
                boardContainer.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
                
                board.forEach((_cell, index) => {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('cell');
                    cellElement.dataset.index = index;
                    cellElement.addEventListener('click', () => handleCellClick(index));
                    boardContainer.appendChild(cellElement);
                });
                
                gameActive = true;
                currentPlayer = 'X';
                statusDisplay.innerHTML = currentPlayerTurn();
                
                // Show win counter for Pro mode
                if (mode === 'pro') {
                    winCounter.style.display = 'block';
                    playerWinsSpan.textContent = '0';
                    computerWinsSpan.textContent = '0';
                    
                    // Generate win progress dots
                    winProgress.innerHTML = '';
                    for (let i = 0; i < modes.pro.winsRequired; i++) {
                        const dot = document.createElement('div');
                        dot.classList.add('win-dot');
                        dot.id = `win-dot-${i}`;
                        winProgress.appendChild(dot);
                    }
                } else {
                    winCounter.style.display = 'none';
                }
            }
            
            // Update win progress visualization
            function updateWinProgress(player) {
                const wins = gameState[player].wins;
                for (let i = 0; i < modes.pro.winsRequired; i++) {
                    const dot = document.getElementById(`win-dot-${i}`);
                    if (dot) {
                        if (i < wins) {
                            dot.classList.add('achieved');
                        } else {
                            dot.classList.remove('achieved');
                        }
                    }
                }
            }
            
            // Handle cell click
            function handleCellClick(index) {
                if (!gameActive || board[index] !== null) return;
                if (currentMode === 'pro' && usedInWinIndices.has(index)) return;
                
                // Player's move
                makeMove(index, 'X');
                
                if (!gameActive) return;
                
                // Computer's move with a slight delay for better UX
                setTimeout(() => {
                    const computerMove = findBestMove();
                    if (computerMove !== -1) {
                        makeMove(computerMove, 'O');
                    }
                }, 500);
            }
            
            // Find the best move for the computer
            function findBestMove() {
                // 1. First, check if computer can win in the next move
                for (let i = 0; i < board.length; i++) {
                    if (board[i] === null && !(currentMode === 'pro' && usedInWinIndices.has(i))) {
                        board[i] = 'O';
                        if (checkWin('O')) {
                            board[i] = null;
                            return i;
                        }
                        board[i] = null;
                    }
                }
                
                // 2. Block player's winning moves (more aggressively)
                const playerThreats = [];
                for (let i = 0; i < board.length; i++) {
                    if (board[i] === null && !(currentMode === 'pro' && usedInWinIndices.has(i))) {
                        board[i] = 'X';
                        if (checkWin('X')) {
                            playerThreats.push(i);
                        }
                        board[i] = null;
                    }
                }
                
                // If player has multiple threats, block the most dangerous one
                if (playerThreats.length > 0) {
                    // Prioritize threats that also create opportunities for computer
                    for (const threat of playerThreats) {
                        board[threat] = 'O';
                        let computerOpportunities = 0;
                        for (let j = 0; j < board.length; j++) {
                            if (board[j] === null && !(currentMode === 'pro' && usedInWinIndices.has(j))) {
                                board[j] = 'O';
                                if (checkWin('O')) computerOpportunities++;
                                board[j] = null;
                            }
                        }
                        board[threat] = null;
                        
                        if (computerOpportunities > 0) {
                            return threat;
                        }
                    }
                    
                    // Otherwise, block a random threat
                    return playerThreats[Math.floor(Math.random() * playerThreats.length)];
                }
                
                // 3. Create forks (positions that create multiple winning opportunities)
                const forkMoves = [];
                for (let i = 0; i < board.length; i++) {
                    if (board[i] === null && !(currentMode === 'pro' && usedInWinIndices.has(i))) {
                        board[i] = 'O';
                        
                        let winOpportunities = 0;
                        for (let j = 0; j < board.length; j++) {
                            if (board[j] === null && !(currentMode === 'pro' && usedInWinIndices.has(j))) {
                                board[j] = 'O';
                                if (checkWin('O')) winOpportunities++;
                                board[j] = null;
                            }
                        }
                        
                        board[i] = null;
                        
                        if (winOpportunities >= 2) {
                            forkMoves.push(i);
                        }
                    }
                }
                
                if (forkMoves.length > 0) {
                    return forkMoves[Math.floor(Math.random() * forkMoves.length)];
                }
                
                // 4. Strategic moves based on game mode
                const strategicMoves = [];
                
                // For larger boards, prioritize center and key positions
                if (boardSize > 3) {
                    const center = Math.floor(boardSize * boardSize / 2);
                    if (board[center] === null && !(currentMode === 'pro' && usedInWinIndices.has(center))) {
                        strategicMoves.push(center);
                    }
                    
                    // Add strategic positions based on board size
                    const strategicPositions = [];
                    const quarter = Math.floor(boardSize / 2);
                    
                    // Add positions that are more likely to create winning lines
                    for (let i = 1; i < boardSize - 1; i++) {
                        for (let j = 1; j < boardSize - 1; j++) {
                            strategicPositions.push(i * boardSize + j);
                        }
                    }
                    
                    // Shuffle to make it less predictable
                    strategicPositions.sort(() => Math.random() - 0.5);
                    
                    for (const pos of strategicPositions) {
                        if (board[pos] === null && !(currentMode === 'pro' && usedInWinIndices.has(pos))) {
                            strategicMoves.push(pos);
                        }
                    }
                    
                    // Add corners as backup
                    const corners = [0, boardSize-1, boardSize*(boardSize-1), boardSize*boardSize-1];
                    for (const corner of corners) {
                        if (board[corner] === null && !(currentMode === 'pro' && usedInWinIndices.has(corner))) {
                            strategicMoves.push(corner);
                        }
                    }
                }
                
                // If we have strategic moves, choose one
                if (strategicMoves.length > 0) {
                    return strategicMoves[Math.floor(Math.random() * strategicMoves.length)];
                }
                
                // 5. If no strategic moves, choose a random available move
                const emptyCells = board.map((val, idx) => 
                    (val === null && !(currentMode === 'pro' && usedInWinIndices.has(idx))) ? idx : null
                ).filter(val => val !== null);
                
                if (emptyCells.length > 0) {
                    return emptyCells[Math.floor(Math.random() * emptyCells.length)];
                }
                
                return -1; // No moves available
            }
            
            // Make a move
            function makeMove(index, player) {
                board[index] = player;
                const cellElement = document.querySelector(`.cell[data-index="${index}"]`);
                cellElement.textContent = player;
                cellElement.classList.add(player.toLowerCase());
                
                if (checkWin(player)) {
                    if (currentMode === 'pro') {
                        // Mark these boxes as used in a win
                        winningIndices.forEach(i => usedInWinIndices.add(i));
                        
                        gameState[player].wins++;
                        
                        // Update win counter
                        if (player === 'X') {
                            playerWinsSpan.textContent = gameState[player].wins;
                        } else {
                            computerWinsSpan.textContent = gameState[player].wins;
                        }
                        
                        // Update win progress visualization
                        updateWinProgress(player);
                        
                        if (gameState[player].wins >= modes.pro.winsRequired) {
                            handleGameEnd(false);
                            highlightWinningCells();
                            statusDisplay.innerHTML = gameWonMessage();
                        } else {
                            highlightWinningCells();
                            statusDisplay.innerHTML = `${winningMessage()} ${gameState[player].wins}/${modes.pro.winsRequired} wins`;
                            // Mark winning cells as used
                            winningIndices.forEach(i => {
                                const cell = document.querySelector(`.cell[data-index="${i}"]`);
                                cell.classList.add('used-in-win');
                            });
                            // Continue playing
                            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                        }
                    } else {
                        handleGameEnd(false);
                        highlightWinningCells();
                        statusDisplay.innerHTML = winningMessage();
                    }
                } else if (isDraw()) {
                    handleGameEnd(true);
                    statusDisplay.innerHTML = drawMessage();
                } else {
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    statusDisplay.innerHTML = currentPlayerTurn();
                }
            }
            
            // Check for a win
            function checkWin(player) {
                const positions = [];
                board.forEach((value, index) => {
                    if (value === player) positions.push(index);
                });
                
                // Check rows
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col <= boardSize - requiredLength; col++) {
                        const indices = [];
                        let valid = true;
                        for (let i = 0; i < requiredLength; i++) {
                            const idx = row * boardSize + col + i;
                            indices.push(idx);
                            // In Pro mode, check if any of these indices are already used in a win
                            if (currentMode === 'pro' && usedInWinIndices.has(idx)) {
                                valid = false;
                            }
                        }
                        
                        if (valid && indices.every(index => positions.includes(index))) {
                            winningIndices = indices;
                            return true;
                        }
                    }
                }
                
                // Check columns
                for (let col = 0; col < boardSize; col++) {
                    for (let row = 0; row <= boardSize - requiredLength; row++) {
                        const indices = [];
                        let valid = true;
                        for (let i = 0; i < requiredLength; i++) {
                            const idx = (row + i) * boardSize + col;
                            indices.push(idx);
                            if (currentMode === 'pro' && usedInWinIndices.has(idx)) {
                                valid = false;
                            }
                        }
                        
                        if (valid && indices.every(index => positions.includes(index))) {
                            winningIndices = indices;
                            return true;
                        }
                    }
                }
                
                // Check diagonals (top-left to bottom-right)
                for (let row = 0; row <= boardSize - requiredLength; row++) {
                    for (let col = 0; col <= boardSize - requiredLength; col++) {
                        const indices = [];
                        let valid = true;
                        for (let i = 0; i < requiredLength; i++) {
                            const idx = (row + i) * boardSize + col + i;
                            indices.push(idx);
                            if (currentMode === 'pro' && usedInWinIndices.has(idx)) {
                                valid = false;
                            }
                        }
                        
                        if (valid && indices.every(index => positions.includes(index))) {
                            winningIndices = indices;
                            return true;
                        }
                    }
                }
                
                // Check diagonals (top-right to bottom-left)
                for (let row = 0; row <= boardSize - requiredLength; row++) {
                    for (let col = requiredLength - 1; col < boardSize; col++) {
                        const indices = [];
                        let valid = true;
                        for (let i = 0; i < requiredLength; i++) {
                            const idx = (row + i) * boardSize + col - i;
                            indices.push(idx);
                            if (currentMode === 'pro' && usedInWinIndices.has(idx)) {
                                valid = false;
                            }
                        }
                        
                        if (valid && indices.every(index => positions.includes(index))) {
                            winningIndices = indices;
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Highlight winning cells
            function highlightWinningCells() {
                winningIndices.forEach(index => {
                    const cell = document.querySelector(`.cell[data-index="${index}"]`);
                    cell.classList.add('winning-cell');
                });
            }
            
            // Check for a draw
            function isDraw() {
                if (currentMode === 'pro') {
                    // In Pro mode, a draw happens when no more moves are available
                    for (let i = 0; i < board.length; i++) {
                        if (board[i] === null && !usedInWinIndices.has(i)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return !board.includes(null);
                }
            }
            
            // Handle game end
            function handleGameEnd(draw) {
                gameActive = false;
                statusDisplay.innerHTML = draw ? drawMessage() : 
                    (currentMode === 'pro' && (gameState['X'].wins >= modes.pro.winsRequired || 
                    gameState['O'].wins >= modes.pro.winsRequired)) ? gameWonMessage() : winningMessage();
            }
            
            // Restart game
            function restartGame() {
                if (currentMode) {
                    initGame(currentMode);
                }
            }
            
            // Event listeners
            modeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const mode = button.dataset.mode;
                    initGame(mode);
                });
            });
            
            restartBtn.addEventListener('click', restartGame);
        });
    </script>
</body>
</html>